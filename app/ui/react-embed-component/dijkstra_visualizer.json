{"code": "import React, { useState, useEffect, useRef } from 'react';\n\nconst DijkstraVisualizer = () => {\n  // Grid dimensions\n  const GRID_WIDTH = 20;\n  const GRID_HEIGHT = 15;\n\n  // Possible node states\n  const NODE_STATES = {\n    UNVISITED: 'unvisited',\n    VISITED: 'visited',\n    WALL: 'wall',\n    START: 'start',\n    END: 'end',\n    PATH: 'path',\n  };\n\n  // Default start and end nodes\n  const DEFAULT_START_NODE = { row: 5, col: 5 };\n  const DEFAULT_END_NODE = { row: 10, col: 15 };\n\n  // React states\n  const [grid, setGrid] = useState([]);\n  const [startNode, setStartNode] = useState(DEFAULT_START_NODE);\n  const [endNode, setEndNode] = useState(DEFAULT_END_NODE);\n  const [isVisualizing, setIsVisualizing] = useState(false);\n  const [isMouseDown, setIsMouseDown] = useState(false);\n  const [isBuildingWall, setIsBuildingWall] = useState(null);\n\n  // Reference to timeout for visualization\n  const timeoutRef = useRef(null);\n\n  // Initialize the grid on component mount\n  useEffect(() => {\n    initializeGrid();\n  }, []);\n\n  // Function to create the initial grid\n  const initializeGrid = () => {\n    const newGrid = [];\n    for (let row = 0; row < GRID_HEIGHT; row++) {\n      const currentRow = [];\n      for (let col = 0; col < GRID_WIDTH; col++) {\n        currentRow.push({\n          row,\n          col,\n          distance: Infinity,\n          isVisited: false,\n          isWall: false,\n          previousNode: null,\n          state: NODE_STATES.UNVISITED,\n        });\n      }\n      newGrid.push(currentRow);\n    }\n\n    // Set start and end nodes\n    newGrid[DEFAULT_START_NODE.row][DEFAULT_START_NODE.col].state = NODE_STATES.START;\n    newGrid[DEFAULT_END_NODE.row][DEFAULT_END_NODE.col].state = NODE_STATES.END;\n\n    setGrid(newGrid);\n  };\n\n  // Function to handle mouse down event\n  const handleMouseDown = (row, col) => {\n    setIsMouseDown(true);\n\n    if (grid[row][col].state === NODE_STATES.START || grid[row][col].state === NODE_STATES.END) {\n      return;\n    }\n\n    const isWall = !grid[row][col].isWall;\n    setIsBuildingWall(isWall);\n\n    toggleWall(row, col);\n  };\n\n  // Function to handle mouse enter event\n  const handleMouseEnter = (row, col) => {\n    if (!isMouseDown || grid[row][col].state === NODE_STATES.START || grid[row][col].state === NODE_STATES.END) {\n      return;\n    }\n\n    toggleWall(row, col);\n  };\n\n  // Function to handle mouse up event\n  const handleMouseUp = () => {\n    setIsMouseDown(false);\n    setIsBuildingWall(null);\n  };\n\n  // Function to toggle wall state for a node\n  const toggleWall = (row, col) => {\n    if (grid[row][col].state === NODE_STATES.START || grid[row][col].state === NODE_STATES.END) {\n      return;\n    }\n\n    if (isBuildingWall !== null) {\n      const newGrid = grid.map(rows =>\n        rows.map(node =>\n          node.row === row && node.col === col ? { ...node, isWall: isBuildingWall, state: isBuildingWall ? NODE_STATES.WALL : NODE_STATES.UNVISITED } : node\n        )\n      );\n      setGrid(newGrid);\n    }\n  };\n\n  // Helper function to get unvisited neighbors of a node\n  const getUnvisitedNeighbors = (node, currentGrid) => {\n    const neighbors = [];\n    const { row, col } = node;\n\n    if (row > 0) neighbors.push(currentGrid[row - 1][col]);\n    if (row < GRID_HEIGHT - 1) neighbors.push(currentGrid[row + 1][col]);\n    if (col > 0) neighbors.push(currentGrid[row][col - 1]);\n    if (col < GRID_WIDTH - 1) neighbors.push(currentGrid[row][col + 1]);\n\n    return neighbors.filter(neighbor => !neighbor.isVisited && !neighbor.isWall);\n  };\n\n  // Dijkstra's Algorithm implementation\n  const visualizeDijkstra = async () => {\n    if (isVisualizing) return;\n    setIsVisualizing(true);\n\n    const startNodeObj = grid[startNode.row][startNode.col];\n    const endNodeObj = grid[endNode.row][endNode.col];\n\n    const newGrid = grid.map(rows =>\n      rows.map(node => ({\n        ...node,\n        distance: Infinity,\n        isVisited: false,\n        previousNode: null,\n        state: node.state === NODE_STATES.PATH ? NODE_STATES.UNVISITED : node.state,\n      }))\n    );\n\n    newGrid[startNode.row][startNode.col].distance = 0;\n    newGrid[startNode.row][startNode.col].isWall = false;\n    newGrid[endNode.row][endNode.col].isWall = false;\n\n    setGrid(newGrid);\n\n    const visitedNodesInOrder = [];\n    const unvisitedNodes = getAllNodes(newGrid);\n\n    while (unvisitedNodes.length) {\n      sortNodesByDistance(unvisitedNodes);\n      const closestNode = unvisitedNodes.shift();\n\n      if (closestNode.isWall) continue;\n\n      if (closestNode.distance === Infinity) break;\n\n      closestNode.isVisited = true;\n      visitedNodesInOrder.push(closestNode);\n\n      if (closestNode.row === endNodeObj.row && closestNode.col === endNodeObj.col) {\n        await visualizeShortestPath(newGrid, visitedNodesInOrder);\n        setIsVisualizing(false);\n        return;\n      }\n\n      updateUnvisitedNeighbors(closestNode, newGrid);\n\n      await new Promise(resolve => {\n        timeoutRef.current = setTimeout(() => {\n          setGrid(currentGrid =>\n            currentGrid.map(rows =>\n              rows.map(node =>\n                node.row === closestNode.row && node.col === closestNode.col ? { ...node, ...closestNode } : node\n              )\n            )\n          );\n          resolve();\n        }, 10);\n      });\n      if (!isVisualizing) break;\n    }\n    setIsVisualizing(false);\n  };\n\n  const getAllNodes = (grid) => {\n    const nodes = [];\n    for (const row of grid) {\n      for (const node of row) {\n        nodes.push(node);\n      }\n    }\n    return nodes;\n  };\n\n  const sortNodesByDistance = (unvisitedNodes) => {\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n  };\n\n  const updateUnvisitedNeighbors = (node, currentGrid) => {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, currentGrid);\n    for (const neighbor of unvisitedNeighbors) {\n      neighbor.distance = node.distance + 1;\n      neighbor.previousNode = node;\n    }\n  };\n\n  const visualizeShortestPath = async (grid, visitedNodesInOrder) => {\n    const shortestPathNodes = getNodesInShortestPathOrder(grid);\n\n    for (const node of shortestPathNodes) {\n      if (node.state === NODE_STATES.START || node.state === NODE_STATES.END) continue;\n\n      await new Promise(resolve => {\n        timeoutRef.current = setTimeout(() => {\n          setGrid(currentGrid =>\n            currentGrid.map(rows =>\n              rows.map(n =>\n                n.row === node.row && n.col === node.col ? { ...n, state: NODE_STATES.PATH } : n\n              )\n            )\n          );\n          resolve();\n        }, 50);\n      });\n    }\n  };\n\n  const getNodesInShortestPathOrder = (grid) => {\n    const shortestPathNodesInOrder = [];\n    let currentNode = grid[endNode.row][endNode.col];\n    while (currentNode !== null && currentNode.previousNode) {\n      shortestPathNodesInOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return shortestPathNodesInOrder;\n  };\n\n  const resetGrid = () => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n    setIsVisualizing(false);\n    initializeGrid();\n  };\n\n  const stopVisualization = () => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n    setIsVisualizing(false);\n  };\n\n  return (\n    <div className=\"container\">\n      <h1>Dijkstra's Algorithm Visualizer</h1>\n      <div className=\"controls\">\n        <button onClick={visualizeDijkstra} disabled={isVisualizing}>\n          Visualize Dijkstra's\n        </button>\n        <button onClick={resetGrid} disabled={isVisualizing}>\n          Reset Grid\n        </button>\n        <button onClick={stopVisualization} disabled={!isVisualizing}>\n            Stop Visualization\n        </button>\n      </div>\n      <div className=\"grid\">\n        {grid.map((row, rowIndex) => (\n          <div key={rowIndex} className=\"row\">\n            {row.map((node, nodeIndex) => (\n              <div\n                key={nodeIndex}\n                className={\\`node \\${node.state} \\${node.isWall ? 'wall' : ''}\\`}\n                onMouseDown={() => handleMouseDown(node.row, node.col)}\n                onMouseEnter={() => handleMouseEnter(node.row, node.col)}\n                onMouseUp={handleMouseUp}\n                onMouseLeave={() => { if (isMouseDown) handleMouseUp(); }}\n              ></div>\n            ))}\n          </div>\n        ))}\n      </div>\n      <style jsx>{\\`\n        .container {\n          display: flex;\n          flex-direction: column;\n          align-items: center;\n          font-family: sans-serif;\n        }\n\n        .controls {\n          margin-bottom: 20px;\n        }\n\n        button {\n          padding: 10px 20px;\n          margin: 0 10px;\n          border: none;\n          background-color: #4CAF50;\n          color: white;\n          cursor: pointer;\n          border-radius: 5px;\n        }\n\n        button:disabled {\n          background-color: #cccccc;\n          cursor: not-allowed;\n        }\n\n        .grid {\n          display: flex;\n          flex-direction: column;\n        }\n\n        .row {\n          display: flex;\n        }\n\n        .node {\n          width: 25px;\n          height: 25px;\n          border: 1px solid #ccc;\n          box-sizing: border-box;\n        }\n\n        .node.start {\n          background-color: #007bff;\n        }\n\n        .node.end {\n          background-color: #dc3545;\n        }\n\n        .node.wall {\n          background-color: black;\n        }\n\n        .node.visited {\n          background-color: #ffc107;\n        }\n\n        .node.path {\n          background-color: #28a745;\n        }\n      \\`}</style>\n    </div>\n  );\n};\n\nexport default DijkstraVisualizer;"}